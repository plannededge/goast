name: AI Issue Processor

on:
  issues:
    types: [opened, reopened]

permissions:
  issues: write
  contents: read

jobs:
  process-issue:
    runs-on: ubuntu-latest

    # Only process issues from our templates (have type labels)
    if: |
      contains(github.event.issue.labels.*.name, 'type:bug') ||
      contains(github.event.issue.labels.*.name, 'type:feature') ||
      contains(github.event.issue.labels.*.name, 'type:enhancement')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine template type
        id: template
        run: |
          if [[ "${{ contains(github.event.issue.labels.*.name, 'type:bug') }}" == "true" ]]; then
            echo "type=bug" >> $GITHUB_OUTPUT
            echo "template=bug_report.yml" >> $GITHUB_OUTPUT
          elif [[ "${{ contains(github.event.issue.labels.*.name, 'type:feature') }}" == "true" ]]; then
            echo "type=feature" >> $GITHUB_OUTPUT
            echo "template=feature_request.yml" >> $GITHUB_OUTPUT
          else
            echo "type=feedback" >> $GITHUB_OUTPUT
            echo "template=feedback.yml" >> $GITHUB_OUTPUT
          fi

      - name: Parse issue form
        id: parser
        uses: issue-ops/parser@v4
        with:
          body: ${{ github.event.issue.body }}
          issue-form-template: ${{ steps.template.outputs.template }}

      - name: Normalise parsed data
        id: normaliser
        run: |
          # Read the parser output and convert 'None' values to 'Not provided'
          # This handles dropdown fields that weren't selected in the form
          # Use a file to avoid shell quoting issues with special characters in JSON
          cat > /tmp/parsed_json.txt << 'JSONEOF'
          ${{ steps.parser.outputs.json }}
          JSONEOF

          # Create jq filter file
          cat > /tmp/normalise.jq << 'JQEOF'
          # Feature request fields
          if .category == "None" then .category = "Not provided" else . end |
          if .target == "None" then .target = "Not provided" else . end |
          if .effort == "None" then .effort = "Not provided" else . end |
          if .alternatives == "None" or .alternatives == "_No response_" or .alternatives == "" then .alternatives = "Not provided" else . end |
          if .context == "None" or .context == "_No response_" or .context == "" then .context = "Not provided" else . end |
          if .terms == "None" or .terms == "" then .terms = [] else . end |

          # Bug report fields
          if .severity == "None" then .severity = "Not provided" else . end |
          if .area == "None" or .area == "" or .area == [] then .area = ["Not provided"] else . end |
          if .environment == "None" or .environment == "_No response_" or .environment == "" then .environment = "Not provided" else . end |
          if .screenshots == "None" or .screenshots == "_No response_" or .screenshots == "" then .screenshots = "Not provided" else . end |
          if .additional == "None" or .additional == "_No response_" or .additional == "" then .additional = "Not provided" else . end |

          # Feedback fields
          if ."feedback-type" == "None" then ."feedback-type" = "Not provided" else . end |
          if .importance == "None" then .importance = "Not provided" else . end
          JQEOF

          # Apply normalisation
          NORMALISED_JSON=$(jq -f /tmp/normalise.jq /tmp/parsed_json.txt)

          # Write to file for next step (GitHub Actions outputs can't handle multi-line JSON)
          echo "$NORMALISED_JSON" > /tmp/normalised_json.txt
          echo "json_file=/tmp/normalised_json.txt" >> $GITHUB_OUTPUT

      - name: Prepare API request
        id: prepare
        run: |
          # Save issue data to files to handle special characters safely
          echo '${{ github.event.issue.title }}' > /tmp/issue_title.txt
          # Use heredoc for issue body to handle multi-line content and special characters
          cat > /tmp/issue_body.txt << 'BODYEOF'
          ${{ github.event.issue.body }}
          BODYEOF
          # Normalised JSON is already in the file from the previous step
          echo '${{ steps.template.outputs.type }}' > /tmp/template_type.txt

      - name: Call OpenAI API
        id: openai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Read data from files
          ISSUE_TITLE=$(cat /tmp/issue_title.txt)
          ISSUE_BODY=$(cat /tmp/issue_body.txt)
          PARSED_JSON=$(cat /tmp/normalised_json.txt)
          TEMPLATE_TYPE=$(cat /tmp/template_type.txt)

          # Build the response schema for the current issue type
          case "$TEMPLATE_TYPE" in
            bug)
              cp .github/schemas/bug-schema.json /tmp/response_schema.json
              ;;
            feature)
              cp .github/schemas/feature-schema.json /tmp/response_schema.json
              ;;
            feedback)
              cp .github/schemas/feedback-schema.json /tmp/response_schema.json
              ;;
            *)
              echo "error=true" >> $GITHUB_OUTPUT
              echo "error_message=Unknown template type: $TEMPLATE_TYPE" >> $GITHUB_OUTPUT
              exit 0
              ;;
          esac

          # Build the request payload
          cat > /tmp/openai_request.json << 'PAYLOAD_EOF'
          {
            "model": "gpt-5-nano-2025-08-07",
            "messages": [
              {
                "role": "system",
                "content": ""
              },
              {
                "role": "user",
                "content": ""
              }
            ],
            "response_format": {
              "type": "json_schema",
              "json_schema": {}
            }
          }
          PAYLOAD_EOF

          # Create the system prompt
          SYSTEM_PROMPT=$(cat << 'PROMPT_EOF'
          You are the lead product manager for Goast. Use your product, UI/UX, and technical knowledge to interpret issues with nuance and clarity.
          Your output must strictly follow the provided JSON schema for the specific issue type, with no extra keys or free-form sections.
          Write in UK English, using plain, straightforward language that non-technical users can understand. Keep it calm, clear, and lightly conversational.

          ## Goast Context
          - Goast is a temporary group chat that dissolves when inactive.
          - The Polisher smooths message tone while preserving intent.
          - Vibe Check monitors sentiment and can trigger dissolution.
          - The Historian generates a vague summary and awards badges when a Goast ends.
          - The Token Economy adds friction to negativity; kindness is free.
          - Governance is democratic: major decisions require group votes.

          ## Technical Context
          - Next.js 15 (App Router), TypeScript (strict), PostgreSQL with Prisma, WebSocket realtime.
          - Tailwind CSS with the Spectral design system.
          - Release phases: Alpha (Q1 2026), Beta (Q2 2026), V1 (Q3 2026).

          ## Writing Guidelines
          1. Use UK English spelling throughout:
             - colour (not color), behaviour (not behavior), organise (not organize)
             - centre (not center), labelled (not labeled), travelling (not traveling)

          2. Use plain language:
             - Avoid jargon where possible
             - Explain technical terms if they must be used
             - Use active voice
             - Keep sentences concise

          3. Preserve technical accuracy:
             - Keep reproduction steps faithful to the input
             - Maintain code snippets unchanged
             - Preserve error messages verbatim
             - Keep version numbers and technical specifications

          4. Rewrite and clarify the issue:
             - Your primary job is to rewrite the issue content clearly and professionally
             - Fix grammar, spelling, and punctuation throughout
             - Clarify vague language while preserving the user's intent
             - Expand brief inputs into complete, well-structured sentences
             - Use the original issue body and form data as your source material
             - Infer reasonable context from what the user has provided
             - Only use "Not provided" when there is genuinely no content whatsoever to work with
             - For bugs: describe what is actually broken and why it matters
             - For features: explain the problem, the desired outcome, and the value
             - For feedback: capture the essence of what the user is communicating

          5. Tone: Professional yet approachable, neutral and objective, no marketing language or hype

          6. Title rules:
             - Title format: "[Feature]: {verb} {description}" for features, "[Bug]: {verb} {description}" for bugs, "[Feedback]: {verb} {description}" for feedback
             - The title MUST start with the type in brackets: [Feature], [Bug], or [Feedback]
             - After the bracket, use a colon, then a space, then an approved verb
             - Approved verbs: Add, Fix, Implement, Improve, Enhance, Remove, Update, Create, Delete, Change, Support, Allow, Prevent, Correct, Reduce, Increase, Enable, Disable, Simplify, Clarify, Align, Adjust, Refine, Expand, Restrict, Consolidate, Document, Investigate, Resolve, Restore, Stabilise, Optimise
             - Use sentence case: first word capitalised, the rest lower case unless proper nouns
             - Keep it short, specific, and meaningful as a changelog entry
             - Use plain UK English and avoid jargon where possible

          7. No emojis or formatting:
             - Do not use emojis
             - Do not use Markdown symbols in text fields (no headings, bullets, blockquotes, or code fences)
             - Keep text fields as plain sentences

          8. Lists and nuance:
             - Use lists only when the schema expects a list (for example, steps to reproduce)
             - Avoid list-heavy responses; add brief nuance where helpful
             - If you include a suggestion, question, or opinion, clearly label it with "Suggestion:", "Question:", or "Opinion:"

          9. Labels:
             - Use only the allowed labels listed below
             - Never invent new labels or variations

          ## Label Selection Guidelines
          Available labels (use ONLY these exact values):

          TYPE: type:bug, type:feature, type:enhancement, type:docs, type:chore, type:security, type:research
          PRIORITY: priority:critical, priority:high, priority:medium, priority:low
          STATUS: status:triage (default)
          AREA: area:frontend, area:backend, area:ai, area:infra, area:mobile, area:database, area:realtime
          EFFORT: effort:xs, effort:s, effort:m, effort:l, effort:xl
          BUG SEVERITY: bug:critical, bug:major, bug:minor, bug:cosmetic, bug:regression
          FEATURE CATEGORY: feature:core, feature:governance, feature:identity, feature:economy, feature:dissolution, feature:ai-polish
          RELEASE: release:alpha, release:beta, release:v1
          EXPERIMENT: release:experiment
          STANDALONE: good-first-issue, help-wanted

          Rules:
          - Always include exactly ONE type: label
          - Include relevant area: labels (can be multiple)
          - For bugs, include ONE bug: severity label
          - For features, include ONE feature: category label
          - Estimate effort: if enough information is provided
          - Only assign priority: if clearly urgent/critical
          - Add good-first-issue if the task seems straightforward
          - Add help-wanted if community contribution would be valuable

          ## Confidence Scoring
          - 0.9-1.0: Very confident, clear requirements, obvious labels
          - 0.7-0.89: Confident, minor ambiguities
          - 0.5-0.69: Moderate confidence, some assumptions made
          - Below 0.5: Low confidence, flag for careful review

          ## Flags to Consider
          unclear_requirements, potential_duplicate, needs_more_info, sensitive_content, complex_issue, cross_cutting_concern, scope_creep_risk

          ---

          PROMPT_EOF
          )

          # Create the user prompt with issue data and extra context
          USER_PROMPT=$(cat << PROMPT_EOF
          You are processing a Goast issue. Use the context below and return JSON that matches the schema exactly.

          Goast purpose: ephemeral, safety-first group chats for teens and young adults, no permanent feed, no DMs.
          Goast features: Polisher, Vibe Check, Historian, Token Economy, democratic governance.
          Goast stack: Next.js 15, TypeScript, PostgreSQL + Prisma, WebSocket, Tailwind + Spectral.

          Template Type: ${TEMPLATE_TYPE}
          Original Title: ${ISSUE_TITLE}

          Parsed Form Data (authoritative):
          ${PARSED_JSON}

          Original Issue Body (for reference):
          ${ISSUE_BODY}
          PROMPT_EOF
          )

          # Update the request with the actual prompts and schema
          jq --arg system "$SYSTEM_PROMPT" \
            --arg user "$USER_PROMPT" \
            --slurpfile schema /tmp/response_schema.json \
            '.messages[0].content = $system
            | .messages[1].content = $user
            | .response_format.json_schema = $schema[0]' \
            /tmp/openai_request.json > /tmp/openai_request_final.json

          # Make API request
          HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/openai_response.json \
            -X POST \
            "https://api.openai.com/v1/chat/completions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @/tmp/openai_request_final.json)

          echo "API Response Code: $HTTP_CODE"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "error=true" >> $GITHUB_OUTPUT
            echo "error_message=API returned status $HTTP_CODE" >> $GITHUB_OUTPUT
            cat /tmp/openai_response.json
            exit 0
          fi

          # Extract the generated content
          GENERATED=$(jq -r '.choices[0].message.content // empty' /tmp/openai_response.json)

          if [ -z "$GENERATED" ]; then
            echo "error=true" >> $GITHUB_OUTPUT
            echo "error_message=Failed to extract response from OpenAI API" >> $GITHUB_OUTPUT
            cat /tmp/openai_response.json
            exit 0
          fi

          # Validate it's valid JSON
          if ! echo "$GENERATED" | jq . > /dev/null 2>&1; then
            echo "error=true" >> $GITHUB_OUTPUT
            echo "error_message=OpenAI returned invalid JSON" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Validate issue type matches the template
          AI_TYPE=$(echo "$GENERATED" | jq -r '.issue_type // empty')
          if [ "$AI_TYPE" != "$TEMPLATE_TYPE" ]; then
            echo "error=true" >> $GITHUB_OUTPUT
            echo "error_message=AI issue_type mismatch: expected $TEMPLATE_TYPE, got $AI_TYPE" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Enforce verb-first titles for changelog-friendly consistency
          AI_TITLE=$(echo "$GENERATED" | jq -r '.title // empty')
          if ! echo "$AI_TITLE" | grep -Eq '^\[[^]]+\]: (Add|Fix|Implement|Improve|Enhance|Remove|Update|Create|Delete|Change|Support|Allow|Prevent|Correct|Reduce|Increase|Enable|Disable|Simplify|Clarify|Align|Adjust|Refine|Expand|Restrict|Consolidate|Document|Investigate|Resolve|Restore|Stabilise|Optimise)\b'; then
            echo "error=true" >> $GITHUB_OUTPUT
            echo "error_message=AI title does not start with an approved verb: $AI_TITLE" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Enforce sentence case after the verb (allow common proper nouns)
          TITLE_CORE=${AI_TITLE#*: }
          TITLE_AFTER_VERB=${TITLE_CORE#* }
          TITLE_SECOND_WORD=${TITLE_AFTER_VERB%% *}
          if [ -n "$TITLE_SECOND_WORD" ] && echo "$TITLE_SECOND_WORD" | grep -Eq '^[A-Z]'; then
            case "$TITLE_SECOND_WORD" in
              Goast|AI|PWA|UI|UX|API|WebSocket|Prisma|PostgreSQL|Next.js|TypeScript|GDPR|EU|SSO|OAuth|JWT|SQL|CSS|HTML|JSON|XML|HTTP|HTTPS|DNS|URL|URI|REST|GraphQL)
                ;;
              *)
                echo "error=true" >> $GITHUB_OUTPUT
                echo "error_message=AI title is not sentence case: $AI_TITLE" >> $GITHUB_OUTPUT
                exit 0
                ;;
            esac
          fi

          # Save for next step
          echo "$GENERATED" > /tmp/ai_result.json
          echo "success=true" >> $GITHUB_OUTPUT

      - name: Update issue on success
        if: steps.openai.outputs.success == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          # Read the AI response
          RESPONSE=$(cat /tmp/ai_result.json)
          TEMPLATE_TYPE=$(cat /tmp/template_type.txt)

          # Extract fields
          NEW_TITLE=$(echo "$RESPONSE" | jq -r '.title')
          LABELS=$(echo "$RESPONSE" | jq -r '.labels | join(",")')
          REASONING=$(echo "$RESPONSE" | jq -r '.label_reasoning')
          CONFIDENCE=$(echo "$RESPONSE" | jq -r '.confidence.overall')
          LABEL_CONFIDENCE=$(echo "$RESPONSE" | jq -r '.confidence.labels')
          REWRITE_CONFIDENCE=$(echo "$RESPONSE" | jq -r '.confidence.rewrite')
          FLAGS=$(echo "$RESPONSE" | jq -r 'if .flags | length > 0 then .flags | join(", ") else "None" end')

          # Build a deterministic issue body from structured fields
          if [ "$TEMPLATE_TYPE" = "bug" ]; then
            SUMMARY=$(echo "$RESPONSE" | jq -r '.issue.summary')
            EXPECTED=$(echo "$RESPONSE" | jq -r '.issue.expected_behaviour')
            ACTUAL=$(echo "$RESPONSE" | jq -r '.issue.actual_behaviour')
            SEVERITY=$(echo "$RESPONSE" | jq -r '.issue.severity')
            ENVIRONMENT=$(echo "$RESPONSE" | jq -r '.issue.environment')
            EVIDENCE=$(echo "$RESPONSE" | jq -r '.issue.evidence')
            ADDITIONAL=$(echo "$RESPONSE" | jq -r '.issue.additional_context')
            STEPS=$(echo "$RESPONSE" | jq -r '.issue.steps_to_reproduce[]?')
            AREAS=$(echo "$RESPONSE" | jq -r '.issue.affected_areas[]?')

            {
              echo "## Summary"
              echo "$SUMMARY"
              echo ""
              echo "## Steps to Reproduce"
              if [ -n "$STEPS" ]; then
                echo "$STEPS" | nl -w2 -s'. '
              else
                echo "Not provided"
              fi
              echo ""
              echo "## Expected Behaviour"
              echo "$EXPECTED"
              echo ""
              echo "## Actual Behaviour"
              echo "$ACTUAL"
              echo ""
              echo "## Severity"
              echo "$SEVERITY"
              echo ""
              echo "## Affected Areas"
              if [ -n "$AREAS" ]; then
                echo "$AREAS" | sed 's/^/- /'
              else
                echo "Not provided"
              fi
              echo ""
              echo "## Environment"
              echo "$ENVIRONMENT"
              echo ""
              echo "## Evidence"
              echo "$EVIDENCE"
              echo ""
              echo "## Additional Context"
              echo "$ADDITIONAL"
            } > /tmp/issue_body.md
          elif [ "$TEMPLATE_TYPE" = "feature" ]; then
            PROBLEM=$(echo "$RESPONSE" | jq -r '.issue.problem_statement')
            SOLUTION=$(echo "$RESPONSE" | jq -r '.issue.proposed_solution')
            ALTERNATIVES=$(echo "$RESPONSE" | jq -r '.issue.alternatives_considered')
            CATEGORY=$(echo "$RESPONSE" | jq -r '.issue.category')
            TARGET=$(echo "$RESPONSE" | jq -r '.issue.target_release')
            EFFORT=$(echo "$RESPONSE" | jq -r '.issue.estimated_effort')
            CONTEXT=$(echo "$RESPONSE" | jq -r '.issue.additional_context')
            CONTRIBUTION=$(echo "$RESPONSE" | jq -r '.issue.contribution_interest')

            {
              echo "## Problem Statement"
              echo "$PROBLEM"
              echo ""
              echo "## Proposed Solution"
              echo "$SOLUTION"
              echo ""
              echo "## Alternatives Considered"
              echo "$ALTERNATIVES"
              echo ""
              echo "## Feature Category"
              echo "$CATEGORY"
              echo ""
              echo "## Target Release"
              echo "$TARGET"
              echo ""
              echo "## Estimated Effort"
              echo "$EFFORT"
              echo ""
              echo "## Additional Context"
              echo "$CONTEXT"
              echo ""
              echo "## Contribution Interest"
              if [ "$CONTRIBUTION" = "true" ]; then
                echo "Yes"
              else
                echo "No"
              fi
            } > /tmp/issue_body.md
          else
            FEEDBACK_TYPE=$(echo "$RESPONSE" | jq -r '.issue.feedback_type')
            FEEDBACK=$(echo "$RESPONSE" | jq -r '.issue.feedback')
            IMPORTANCE=$(echo "$RESPONSE" | jq -r '.issue.importance')
            CONTEXT=$(echo "$RESPONSE" | jq -r '.issue.additional_context')
            AREAS=$(echo "$RESPONSE" | jq -r '.issue.related_area[]?')

            {
              echo "## Feedback Type"
              echo "$FEEDBACK_TYPE"
              echo ""
              echo "## Feedback"
              echo "$FEEDBACK"
              echo ""
              echo "## Related Area"
              if [ -n "$AREAS" ]; then
                echo "$AREAS" | sed 's/^/- /'
              else
                echo "Not provided"
              fi
              echo ""
              echo "## Importance"
              echo "$IMPORTANCE"
              echo ""
              echo "## Additional Context"
              echo "$CONTEXT"
            } > /tmp/issue_body.md
          fi

          # Create the updated body with AI processing note
          cat > /tmp/updated_body.md << EOF
          $(cat /tmp/issue_body.md)

          ---

          <details>
          <summary>AI Processing Notes (Moderator View)</summary>

          **Confidence Scores:**
          - Overall: ${CONFIDENCE}
          - Labels: ${LABEL_CONFIDENCE}
          - Rewrite: ${REWRITE_CONFIDENCE}

          **Label Reasoning:**
          ${REASONING}

          **Flags:** ${FLAGS}

          ---
          *This issue was processed by Goast AI (GPT-5 Nano) and is awaiting moderator approval.*
          </details>
          EOF

          # Update the issue title and body
          gh issue edit "$ISSUE_NUMBER" \
            --title "$NEW_TITLE" \
            --body-file /tmp/updated_body.md

          # Add the pending-review label and AI-suggested labels
          gh issue edit "$ISSUE_NUMBER" \
            --add-label "pending-review"

          # Add each AI-suggested label individually (some may already exist)
          for label in $(echo "$LABELS" | tr ',' '\n'); do
            gh issue edit "$ISSUE_NUMBER" --add-label "$label" 2>/dev/null || true
          done

          # Add a comment explaining the AI processing
          gh issue comment "$ISSUE_NUMBER" --body "This issue has been processed by our AI assistant and is awaiting moderator review. A team member will review and approve it shortly."

      - name: Handle API failure
        if: steps.openai.outputs.error == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          # Add pending-review label for manual processing
          gh issue edit "$ISSUE_NUMBER" --add-label "pending-review"

          # Add comment explaining the situation
          gh issue comment "$ISSUE_NUMBER" --body "Our AI assistant was unable to process this issue automatically. A moderator will review it manually. (Error: ${{ steps.openai.outputs.error_message }})"
